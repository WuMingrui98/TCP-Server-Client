# C++多进程实现高并发TCP服务器与客户端

## 实现思路

### 1、TCP服务端

1. 主线程中创建一个线程池，线程池中完成客户端与服务端通讯后的写入日志的操作，将待写入日志的消息添加到消息队列中，交由异步日志线程处理，线程池大小可以根据所在计算机环境的通过调整输入参数自由调整大小。

2. 程序中通过epoll实现IO多路复用，通过epoll监听文件描述符的读写事件。

   * 当出现读事件时，判断是否为监听套接字产生的，若为监听套接字产生的读事件，则接受客户端的连接请求, 建立新的连接, 得到用于通信的套接字文件描述符，若为通信套接字产生的读事件，在完成读操作后，将任务加入任务队列中，交由线程池处理。

   * 当出现写事件时，表示线程池中已经处理了客户端与服务器的通信操作，并将消息写入了日志。现在需要完成服务端写回客户端的操作，并关闭套接字通信。

3. 通过异步日志实现日志的高效写入，通过生成一个子线程独立完成日志的写入，它将需要写入日志的消息从消息队列中取出，并写入serverLog文件中。

4. 封装互斥锁类、条件变量类及信号量类（文件中有两个版本，一个是c++11新特性的版本，传统c++的版本，综合了队友的代码）实现线程同步。

### 2、TCP压力测试客户端

1. 通过argv信息的读入确定并发数、发送消息总数、发送消息内容、服务器Ip地址、端口号，并创建了一个记录每条消息响应时间的数组

2. 主线程创建一个管理者线程，其任务是在工作线程被创建前记录测试开始时间，工作线程被创建并开始向服务器端发送消息时，管理者线程以20毫秒的频次检测工作线程是否发送完所有消息并全部退出，最后在所有工作线程退出后记录测试结束时间，并计算qps以及对记录响应时间的数组进行排序，最后打印所需信息

3. 在管理者线程创建之后创建与并发数相当的工作线程进行消息的发送，每个线程在消息发送前与收到服务器回复的这两个时间点分别记录下时间，再计算前后所需时间，将耗时写入记录响应时间的数组，之后再进行下一条消息的发送。若消息已经全部发送完毕，则工作线程退出

## 快速运行代码

### 1、TCP服务端

```shell
# 编译服务端代码
make server
# 运行程序（通过shell运行，参数可以在shell文件中修改)
sh ./server.sh
# 运行程序（命令行）
./server $Port $ThreadNum
```

### 2、TCP压力测试客户端

```shell
# 编译服务端代码
make server
# 运行程序（通过shell运行，参数可以在shell文件中修改)
sh ./client.sh
# 运行程序（命令行）
./client $clients $nsum $message $IP $Port
```

##   测试结果

1. 测试环境: Ubuntu版本18.04

   * 配置：2核4G
   * 带宽：8M
   * 系统盘：80G

2. 测试结果

   ```
   test start time:11:56:38.116
   test end time:11:56:54.512
   qps:7049.99/sec
   Percentage of the requests served within a certain time(ms)
   P50:0.0140ms
   P60:0.0150ms
   P70:0.0170ms
   P80:0.0200ms
   P90:0.0260ms
   P100:3043.9840ms
   ```

## 补充信息：

同组同学用epoll也写了一个客户端，我们也放到文件中，在"补充文件夹"下。
